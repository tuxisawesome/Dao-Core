
import sys


def boot(args): kernel.panic("\nThe kernel is not directly bootable\nPlease use a seperate bootloader to load the kernel.")

def init(drivers,drivernames,configmgr,drivermgr,kernel):
    display = drivers[drivernames.index("display")]
    display.printline("The kernel is not an application.")



def recoveryf(display, mods, config):
    recoveryenabled = configmgr.getvalue(config, "recoveryenabled")
    if recoveryenabled == 0: recoveryenabled = False 
    else: recoveryenabled = True

    if not recoveryenabled:
        x = configmgr.getvalue(mods, "sys")
        y = x.split("/")
        sysctl = drivermgr.load(y[1],y[0])
        sysctl.reset()
    else:
        conf = config
        bootr = configmgr.getvalue(conf, "boot_to_recovery")
        if not bootr == "0":
            conf = configmgr.setvalue(conf, "boot_to_recovery", "0")
            configmgr.writeconfig("config.cfg", conf)
        display.printline("Recovery Mode")
        display.printline("Please restore this device and then reset.")


def main(args):
    isrecovery=False
    if len(args) >= 1:
        for arg in args:
            arg = arg.lower().split("=")
            if arg[0] == "isrecovery" and arg[1] == "true":
                isrecovery = True;continue
            if arg[0] == "path":
                kernel.configpath = arg[1];continue
    
    kernel.args = args
    print(kernel.args)
    mods = configmgr.readconfig("modules.cfg",kernel.configpath)
    init = configmgr.readconfig("init.cfg",kernel.configpath)
    config = configmgr.readconfig("config.cfg",kernel.configpath)

    # Establish constants
    ver = configmgr.getvalue(config, "version")
    verbosedrivers = configmgr.getvalue(config, "verbosedrivers")
    if verbosedrivers == "0": verbosedrivers = False 
    else: verbosedrivers = True
    

    # First load display module
    x = configmgr.getvalue(mods, "display")
    y = x.split("/")
    display = drivermgr.load(y[1],y[0])
    

    display.printline("Dao " + ver + " is starting up!")
    bootr = configmgr.getvalue(config, "boot_to_recovery")
    if bootr == "0": bootr = False 
    else: bootr = True
    if bootr or isrecovery:
        recoveryf(display, mods, config)
    else:
        drivers,drivernames = load_modules(display,mods,verbosedrivers)
        import init as start
        start.init(display,init,verbosedrivers,configmgr,drivermgr,drivers,drivernames,kernel)
    '''
    You can also use the default __import__ function as
    module = __import__(custom)
    '''


def load_modules(display,mods,verbosedrivers):
    # load other modules
    drivers = []
    drivernames = []
    for mod in mods:
        modx = mod.split("=")
        keys = []
        vals = []
        for line in mods:
            x = line.split("=")
            keys.append(x[0])
            vals.append(x[1])
        y = vals[keys.index(modx[0])].strip("\n")
        yx = y.split("/")
        drv = drivermgr.load(yx[1],yx[0])
        drivernames.append(modx[0])
        drivers.append(drv)
        drv.init(drivers, drivernames, configmgr, drivermgr, kernel)
        if verbosedrivers:
            display.printline("*   Loaded module " + modx[0] + " from " + y)
    # find drivers like this: drivers[drivernames.index("[name]")]
    display.printline("*   Drivers Loaded Successfully")
    return drivers,drivernames




class kernel:
    args=[]
    configpath="etc/"
    def panic(message="Unknown"):
        try:
            print("The kernel has reached an unrecoverable error.")
            print("Please force restart the computer.")
            print("Error: " + message)
            while True:
                continue
        except:
            kernel.panic(message)
    def reload_env():
        good_modules = ["sys"]
        s = drivermgr.basicload("sys")
        x = s.modules

        try:
            for mod in x:
                #display.printline("*   '" + mod + "' is reloaded.")
                if mod in good_modules: continue
                del s.modules[mod]
                del mod
                            
        except:
            kernel.reload_env()



# Configmgr
class configmgr:
    def readconfig(file,path=kernel.configpath):
        with open(path + file, "r") as f:
            x = f.readlines()
            y = []
            for line in x:
                if line.startswith("#") or line.startswith("//") or line == "":
                    continue
                else:
                    y.append(line.strip("\n"))
            return y

    def writeconfig(file, config,path=kernel.configpath):
        with open(path + file, "w") as f:
            f.write("# Autogenerated by writeconfig\n")
            for line in config:
                if not line.endswith("\n"):
                    f.write(line + "\n")
                else: f.write(line)
            f.close()
        
    def getvalue(config, key):
        keys = []
        vals = []
        for line in config:
            x = line.split("=")
            keys.append(x[0])
            vals.append(x[1])
        return vals[keys.index(key)].strip("\n")

    def getkeys(config):
        keys = []
        vals = []
        for line in config:
            x = line.split("=")
            keys.append(x[0].strip("\n"))
            vals.append(x[1])
        return keys

    def getkey(config, value):
        keys = []
        vals = []
        for line in config:
            x = line.split("=")
            keys.append(x[0])
            vals.append(x[1])
        return keys[vals.index(value)].strip("\n")

    def setvalue(config, key, value):
        keys = []
        vals = []
        for line in config:
            x = line.split("=")
            keys.append(x[0])
            vals.append(x[1])
        try:
            vals[keys.index(key)] = value
        except ValueError or IndexError:
            keys.append(key)
            vals.append(value)
        newconfig = []
        for z in keys:
            newconfig.append(z + "=" + vals[keys.index(z)])

        return newconfig


    def remkey(config, key):
        keys = []
        vals = []
        for line in config:
            x = line.split("=")
            keys.append(x[0])
            vals.append(x[1])
        try:
            vals.pop(keys.index(key))
            keys.pop(keys.index(key))
        except ValueError:
            pass
        newconfig = []
        for z in keys:
            newconfig.append(z + "=" + vals[keys.index(z)])

        return newconfig



#Drivermgr
class drivermgr:
    def load(name, path_in_lib):
        sys.path.append("lib/" + path_in_lib)    
        return __import__(name.strip("\n"))

    def defload(name, path):
        sys.path.append(path)    
        return __import__(name.strip("\n"))
    
    def basicload(name):
        return __import__(name.strip("\n"))

    def unload(name):
        del name


